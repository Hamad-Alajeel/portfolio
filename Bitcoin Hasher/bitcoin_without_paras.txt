module bitcoin_hash (input logic        clk, reset_n, start,
                     input logic [15:0] message_addr, output_addr,
                    output logic        done, mem_clk, mem_we,
                    output logic [15:0] mem_addr,
                    output logic [31:0] mem_write_data,
                     input logic [31:0] mem_read_data);

parameter num_nonces = 16;

logic begin_stage1;
logic end_stage1;
logic begin_stage2;
logic end_stage2[8];
logic [31:0] hout[8];
logic [15:0] cur_addr;
logic [15:0] offset;
logic        cur_we;
logic [31:0] cur_write_data;
logic [31:0] w_block[8][16];
logic [31:0] message[20];
logic [31:0] hash_complete[16][8];
logic [31:0] hash_in[8];
logic [31:0] hash_out[8][8];
logic [31:0] hash1[8];  
logic [7:0] i;

enum logic [3:0] {IDLE, READ, BUFFER, STAGE11, STAGE21, STAGE22, STAGE31, STAGE32, WRITE} state, next_state;

parameter int k[64] = '{
    32'h428a2f98,32'h71374491,32'hb5c0fbcf,32'he9b5dba5,32'h3956c25b,32'h59f111f1,32'h923f82a4,32'hab1c5ed5,
    32'hd807aa98,32'h12835b01,32'h243185be,32'h550c7dc3,32'h72be5d74,32'h80deb1fe,32'h9bdc06a7,32'hc19bf174,
    32'he49b69c1,32'hefbe4786,32'h0fc19dc6,32'h240ca1cc,32'h2de92c6f,32'h4a7484aa,32'h5cb0a9dc,32'h76f988da,
    32'h983e5152,32'ha831c66d,32'hb00327c8,32'hbf597fc7,32'hc6e00bf3,32'hd5a79147,32'h06ca6351,32'h14292967,
    32'h27b70a85,32'h2e1b2138,32'h4d2c6dfc,32'h53380d13,32'h650a7354,32'h766a0abb,32'h81c2c92e,32'h92722c85,
    32'ha2bfe8a1,32'ha81a664b,32'hc24b8b70,32'hc76c51a3,32'hd192e819,32'hd6990624,32'hf40e3585,32'h106aa070,
    32'h19a4c116,32'h1e376c08,32'h2748774c,32'h34b0bcb5,32'h391c0cb3,32'h4ed8aa4a,32'h5b9cca4f,32'h682e6ff3,
    32'h748f82ee,32'h78a5636f,32'h84c87814,32'h8cc70208,32'h90befffa,32'ha4506ceb,32'hbef9a3f7,32'hc67178f2
};

// Student to add rest of the code here
simplified_sha256 stg1(.clk(clk), .reset_n(reset_n), .start(begin_stage1), .w(w_block[0]), .hash_in(hash_in), .hash_out(hash1), .hash_done(end_stage1));
genvar g;
generate
for(g = 0; g < 8; g+=1) begin: hashing_instances
simplified_sha256 hasher(.clk(clk), .reset_n(reset_n), .start(begin_stage2), .w(w_block[g]), .hash_in(hash_in), .hash_out(hash_out[g]), .hash_done(end_stage2[g]));
end
endgenerate

assign mem_clk = clk;
assign mem_addr = cur_addr + offset;
assign mem_we = cur_we;
assign mem_write_data = cur_write_data;

always_ff @(posedge clk, negedge reset_n)
begin
if(!reset_n) begin
state <= IDLE;
end
else begin
state <= next_state;
case(state)

IDLE: begin
	if(start) begin
	hash_in[0]<= 32'h6A09E667;
	hash_in[1]<= 32'hBB67AE85;
	hash_in[2]<= 32'h3C6EF372;
	hash_in[3]<= 32'hA54FF53A;
	hash_in[4]<= 32'h510E527F;
	hash_in[5]<= 32'h9B05688C;
	hash_in[6]<= 32'h1F83D9AB;
	hash_in[7]<= 32'h5BE0CD19;
	offset <= 0;
	cur_addr <= message_addr;
	cur_we <= 0;
	i <= 0;
	end
	else begin
	hash_in[0]<= 0;
	hash_in[1]<= 0;
	hash_in[2]<= 0;
	hash_in[3]<= 0;
	hash_in[4]<= 0;
	hash_in[5]<= 0;
	hash_in[6]<= 0;
	hash_in[7]<= 0;
	cur_addr <= 0;
	offset <= 0;
	cur_we <= 0;
	i <= 0;
	end
end //BARAYE IDLE

BUFFER:begin
if(offset < 20) offset <= offset;
else begin
offset <= 0;
begin_stage1 <= 1;
for(int x = 0; x < 16; x = x + 1) w_block[0][x] <= message[x];
end
end 

READ: begin
	message[offset] <= mem_read_data;
	offset <= offset + 1;                      
end

STAGE11: begin
	if(end_stage1) begin
	begin_stage1 <= 0;
	begin_stage2 <= 1;
	for(int y = 0; y < 8; y+=1) begin
	hash_in[y] <= hash1[y];
	end
	for(int x = 0; x < 8; x+=1) begin
				  w_block[x][0] <= message[16];
              w_block[x][1] <= message[17];
              w_block[x][2] <= message[18];
              w_block[x][3] <= x;
              w_block[x][4] <= 32'h80000000;
              w_block[x][5] <= 32'h00000000;
              w_block[x][6] <= 32'h00000000;
              w_block[x][7] <= 32'h00000000;
              w_block[x][8] <= 32'h00000000;
              w_block[x][9] <= 32'h00000000;
              w_block[x][10] <= 32'h00000000;
              w_block[x][11] <= 32'h00000000;
              w_block[x][12] <= 32'h00000000;
              w_block[x][13] <= 32'h00000000;
              w_block[x][14] <= 32'h00000000;
              w_block[x][15] <= 32'd640;
	end
	end
	else begin
	begin_stage1 <= 1;
	begin_stage2 <= 0;
	end
end

STAGE21: begin
if(end_stage2[0]) begin
begin_stage2 <= 1;
	for(int y = 0; y < 8; y+=1) begin
		for(int z = 0; z < 8; z+=1) begin
			hash_complete[y][z] <= hash_out[y][z];
		end
	end
	for(int x = 0; x < 8; x+=1) begin
				  w_block[x][0] <= message[16];
              w_block[x][1] <= message[17];
              w_block[x][2] <= message[18];
              w_block[x][3] <= x+8;
              w_block[x][4] <= 32'h80000000;
              w_block[x][5] <= 32'h00000000;
              w_block[x][6] <= 32'h00000000;
              w_block[x][7] <= 32'h00000000;
              w_block[x][8] <= 32'h00000000;
              w_block[x][9] <= 32'h00000000;
              w_block[x][10] <= 32'h00000000;
              w_block[x][11] <= 32'h00000000;
              w_block[x][12] <= 32'h00000000;
              w_block[x][13] <= 32'h00000000;
              w_block[x][14] <= 32'h00000000;
              w_block[x][15] <= 32'd640;
	end
end 
else begin
begin_stage2 <= 1;
end
end

STAGE22: begin
if(end_stage2[0]) begin
hash_in[0]<= 32'h6A09E667;
hash_in[1]<= 32'hBB67AE85;
hash_in[2]<= 32'h3C6EF372;
hash_in[3]<= 32'hA54FF53A;
hash_in[4]<= 32'h510E527F;
hash_in[5]<= 32'h9B05688C;
hash_in[6]<= 32'h1F83D9AB;
hash_in[7]<= 32'h5BE0CD19;
begin_stage2 <= 1;
	for(int y = 0; y < 8; y+=1) begin
		for(int z = 0; z < 8; z+=1) begin
			hash_complete[y+8][z] <= hash_out[y][z];
		end
	end
	for(int x = 0; x < 8; x+=1) begin
			  w_block[x][0] <= hash_complete[x][0];
			  w_block[x][1] <= hash_complete[x][1];
			  w_block[x][2] <= hash_complete[x][2];
			  w_block[x][3] <= hash_complete[x][3];
			  w_block[x][4] <= hash_complete[x][4];
			  w_block[x][5] <= hash_complete[x][5];
			  w_block[x][6] <= hash_complete[x][6];
			  w_block[x][7] <= hash_complete[x][7];
			  w_block[x][8] <= 32'h80000000;
			  w_block[x][9] <= 32'h00000000;
			  w_block[x][10] <= 32'h00000000;
			  w_block[x][11] <= 32'h00000000;
			  w_block[x][12] <= 32'h00000000;
			  w_block[x][13] <= 32'h00000000;
			  w_block[x][14] <= 32'h00000000;
			  w_block[x][15] <= 32'd640;	  
	end
end 
else begin
begin_stage2 <= 1;
end
end

STAGE31: begin
if(end_stage2[0]) begin
begin_stage2 <= 1;
for(int y = 0; y < 8; y+=1) begin
		for(int z = 0; z < 8; z+=1) begin
			hash_complete[y][z] <= hash_out[y][z];
		end
	end
for(int x = 0; x < 8; x+=1) begin
			  w_block[x][0] <= hash_complete[x+8][0];
			  w_block[x][1] <= hash_complete[x+8][1];
			  w_block[x][2] <= hash_complete[x+8][2];
			  w_block[x][3] <= hash_complete[x+8][3];
			  w_block[x][4] <= hash_complete[x+8][4];
			  w_block[x][5] <= hash_complete[x+8][5];
			  w_block[x][6] <= hash_complete[x+8][6];
			  w_block[x][7] <= hash_complete[x+8][7];
			  w_block[x][8] <= 32'h80000000;
			  w_block[x][9] <= 32'h00000000;
			  w_block[x][10] <= 32'h00000000;
			  w_block[x][11] <= 32'h00000000;
			  w_block[x][12] <= 32'h00000000;
			  w_block[x][13] <= 32'h00000000;
			  w_block[x][14] <= 32'h00000000;
			  w_block[x][15] <= 32'd640;	  
	end
end
else begin
begin_stage2 <= 1;
end
end

STAGE32: begin
if(end_stage2[0]) begin
begin_stage2 <= 0;
cur_addr <= output_addr;
for(int y = 0; y < 8; y+=1) begin
		for(int z = 0; z < 8; z+=1) begin
			hash_complete[y+8][z] <= hash_out[y][z];
		end
	end
end
else begin
begin_stage2 <= 1;
end
end

WRITE: begin

              case(i)
              0:begin
              cur_we <= 0;
              cur_write_data <= hash_complete[0][0];
              offset <= 0;
              end
              1: begin
              cur_we <= 1;
              cur_write_data <= 124;
              offset <= 0;
              end
              2: begin
              cur_we <= 1;
              cur_write_data <= 124;
              offset <= 1;
              end
              3: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[2][0];
              offset <= 2;
              end
              4: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[3][0];
              offset <= 3;
              end
              5: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[4][0];
              offset <= 4;
              end
              6: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[5][0];
              offset <= 5;
              end
              7: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[6][0];
              offset <= 6;
              end
              8: begin
              cur_we <= 1;
              cur_write_data <= hash_complete[7][0];
              offset <= 7;
              end
              default: begin
              cur_we <= 0;
              cur_write_data <= 0;
              offset <= 0;
              end
              endcase
              i <= i + 1;
      
end

endcase // BARAYE CASESH

end //BARAYE ELSE
end // BARAYE ALWAYS




always_comb begin
case(state)

IDLE: begin
done = 0;
if(start) next_state = READ;
else next_state = IDLE;
end

READ: begin
done = 0;
next_state = BUFFER;
end

BUFFER: begin
done = 0;
if(offset < 20) next_state = READ;
else next_state = STAGE11;
end

STAGE11: begin
done = 0;
if(end_stage1) next_state = STAGE21;
else next_state = STAGE11;
end

STAGE21: begin
done = 0;
if(end_stage2[0]) next_state = STAGE22;
else next_state = STAGE21;
end

STAGE22: begin
done = 0;
if(end_stage2[0]) next_state = STAGE31;
else next_state = STAGE22;
end

STAGE31: begin
done = 0;
if(end_stage2[0]) next_state = STAGE32;
else next_state = STAGE31;
end

STAGE32: begin
done = 0;
if(end_stage2[0]) next_state = WRITE;
else next_state = STAGE32;
end

WRITE: begin
if(i<=9) begin
next_state = WRITE;
done = 0;
end
else begin
next_state = IDLE;
done = 1;
end
end

endcase

end

endmodule 